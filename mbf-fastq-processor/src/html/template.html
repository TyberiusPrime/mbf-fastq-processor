<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mbf-fastq-processor report</title>

    <script>
      function plot_read_length_distribution(data, container) {
        const inner_container = document.createElement("div");
        inner_container.className = "chart-container";
        inner_container.style.width = "100%";
        inner_container.style.border = "1px solid black;";
        const canvas = document.createElement("canvas");
        inner_container.appendChild(canvas);
        container.appendChild(inner_container);

        const values = data;
        const labels = values.map((_, index) => index); // X-axis labels (positions)

        // Define the chart using Chart.js
        new Chart(canvas, {
          type: "line",
          data: {
            labels: labels, // X-axis labels
            datasets: [
              {
                label: "Expected Error Rate",
                data: values, // Y-axis values
                borderColor: "orange", // Single color for the line
                borderWidth: 2,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  title: (tooltipItems) => {
                    return `Length: ${tooltipItems[0].label}`; // Show X-axis position in tooltip title
                  },
                  label: (tooltipItem) => {
                    return `Value: ${tooltipItem.raw}`; // Show Y value in tooltip label
                  },
                },
              },
            },
            scales: {
              x: { title: { display: true, text: "Position" } },
              y: { title: { display: true, text: "Read count" } },
            },
          },
        });
      }

      function plot_per_position_counts(data, container) {
        const labels = data.a.map((val, i) => i + 1);
        const colorMap = {
          A: "#109648",
          C: "#255c99",
          G: "#f7b32b",
          T: "#d62839",
          N: "black",
        };
        const datasets = Object.entries(data).map(([key, values]) => ({
          label: key.toUpperCase(),
          data: values,
          borderColor: colorMap[key.toUpperCase()] || "grey",
          borderWidth: 2,
          fill: false,
          pointRadius: 3,
          pointHoverRadius: 5,
        }));
        const canvas = document.createElement("canvas");
        container.appendChild(canvas);
        new Chart(canvas, {
          type: "line",
          data: {
            labels: labels,
            datasets: datasets,
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  title: (tooltipItems) => {
                    return `Position: ${tooltipItems[0].label}`;
                  },
                  label: (tooltipItem) => {
                    const datasets = tooltipItem.chart.data.datasets;
                    const total = datasets.reduce(
                      (sum, d) => sum + d.data[tooltipItem.dataIndex],
                      0,
                    );
                    const percent = total
                      ? ((tooltipItem.raw / total) * 100).toFixed(2)
                      : 0;
                    return `${tooltipItem.dataset.label}: ${tooltipItem.raw} (${percent}%)`;
                  },
                },
              },
            },
            scales: {
              x: { title: { display: true, text: "Position" } },
              y: { title: { display: true, text: "Count" } },
            },
          },
        });
      }

      function plot_expected_errors_from_quality_curve(data, container) {
        const labels = data.map((_, index) => index + 1); // X-axis labels (positions)
        const canvas = document.createElement("canvas");
        container.appendChild(canvas);
        new Chart(canvas, {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Expected Error Rate",
                data: data,
                borderColor: "orange",
                borderWidth: 2,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  title: (tooltipItems) => {
                    return `Position: ${tooltipItems[0].label}`;
                  },
                  label: (tooltipItem) => {
                    return `Value: ${tooltipItem.raw}`;
                  },
                },
              },
            },
            scales: {
              x: { title: { display: true, text: "Position" } },
              y: { title: { display: true, text: "Expected Error Rate" } },
            },
          },
        });
      }

      function plot_tag_histogram(histogramData, container) {
        const canvas = document.createElement("canvas");
        container.appendChild(canvas);

        // Extract labels and counts from the new direct mapping format
        const labels = Object.keys(histogramData);
        const counts = Object.values(histogramData);

        // Handle empty label case (empty string key)
        const processedLabels = labels.map(label => label === "" ? "(empty)" : label);

        // Sort by count (descending) and limit to top 50 items for readability
        const combined = labels.map((label, i) => ({
          label: processedLabels[i],
          count: counts[i]
        })); // .sort((a, b) => b.count - a.count);

        const maxItems = 100;
        const limitedCombined = combined.slice(0, maxItems);
        const finalLabels = limitedCombined.map(item => item.label);
        const finalCounts = limitedCombined.map(item => item.count);

        // Create horizontal bar chart (flipped axes)
        new Chart(canvas, {
          type: "bar",
          data: {
            labels: finalLabels, // Y-axis (vertical)
            datasets: [
              {
                label: "Count",
                data: finalCounts, // X-axis (horizontal)
                backgroundColor: "rgba(54, 162, 235, 0.6)",
                borderColor: "rgba(54, 162, 235, 1)",
                borderWidth: 1,
              },
            ],
          },
          options: {
            indexAxis: "y", // This flips the axes - bars go horizontally
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  title: (tooltipItems) => {
                    return `${tooltipItems[0].label}`;
                  },
                  label: (tooltipItem) => {
                    return `Count: ${tooltipItem.raw.toLocaleString()}`;
                  },
                },
              },
            },
            scales: {
              x: {
                title: { display: true, text: "Count" },
                beginAtZero: true,
                ticks: {
                  callback: function(value) {
                    return Number.isInteger(value) ? value : '';
                  }
                }
              },
              y: {
                title: { display: true, text: "Value" },
              },
            },
          },
        });

        // Set canvas height based on number of items
        const itemHeight = 25;
        const minHeight = 200;
        const calculatedHeight = Math.max(
          minHeight,
          finalLabels.length * itemHeight,
        );
        canvas.style.height = `${calculatedHeight}px`;
      }

      function create_table(entries) {
        let table = document.createElement("table");
        for (const [key, value] of Object.entries(entries)) {
          let tr = document.createElement("tr");
          let th = document.createElement("th");
          th.textContent = key;
          tr.appendChild(th);
          let td = document.createElement("td");
          if (value instanceof Node) {
            td.appendChild(value);
          } else {
            td.textContent = value;
          }
          tr.appendChild(td);
          table.appendChild(tr);
        }
        return table;
      }

      function format_input_files(input) {
        const entries = {
          Interleaved: input.interleaved,
        };
        if (input.read1) {
          entries["Read1"] = input.read1.join(", ");
        }
        if (input.read2) {
          entries["Read2"] = input.read2.join(", ");
        }
        if (input.index1) {
          entries["Index1"] = input.index1.join(", ");
        }
        if (input.index2) {
          entries["Index2"] = input.index2.join(", ");
        }
        return create_table(entries);
      }

      function addHead(data) {
        const container = document.getElementById("charts-container");
        let title = "mbf-fastq-processor Report";
        container.appendChild(document.createElement("h1")).textContent = title;
        let section = "Summary";
        container.appendChild(document.createElement("h2")).textContent =
          section;

        container.appendChild(
          create_table({
            Version: data.__.version,
            "Working Directory": data.__.cwd,
            "Input Files": format_input_files(data.__.input_files),
          }),
        );
      }

      function addNavigationLinks(reportOrder) {
        if (reportOrder.length <= 1) {
          return; // Don't add navigation for single report
        }

        const container = document.getElementById("charts-container");
        const navSection = document.createElement("h2");
        navSection.textContent = "Reports";
        container.appendChild(navSection);

        const navList = document.createElement("ul");
        navList.style.listStyle = "none";
        navList.style.padding = "0";
        navList.style.display = "flex";
        navList.style.flexWrap = "wrap";
        navList.style.gap = "1em";

        reportOrder.forEach((key) => {
          const listItem = document.createElement("li");
          const link = document.createElement("a");
          link.href = `#section-${key}`;
          link.textContent = key;
          link.style.textDecoration = "none";
          link.style.color = "#007acc";
          link.style.padding = "0.5em 1em";
          link.style.border = "1px solid #ccc";
          link.style.borderRadius = "4px";
          link.style.display = "block";
          link.addEventListener("mouseover", () => {
            link.style.backgroundColor = "#f0f0f0";
          });
          link.addEventListener("mouseout", () => {
            link.style.backgroundColor = "transparent";
          });
          listItem.appendChild(link);
          navList.appendChild(listItem);
        });

        container.appendChild(navList);
        container.appendChild(document.createElement("hr"));
      }

      function render_number(number) {
        return typeof number === "number" ? number.toLocaleString() : number;
      }

      function addSection(key, sectionData) {
        const container = document.getElementById("charts-container");
        // Add section title with anchor ID and back-to-top button
        const headerContainer = document.createElement("div");
        headerContainer.style.display = "flex";
        headerContainer.style.alignItems = "center";
        headerContainer.style.justifyContent = "space-between";
        headerContainer.style.marginBottom = "0.5em";

        const sectionHeader = document.createElement("h2");
        sectionHeader.textContent = key;
        sectionHeader.id = `section-${key}`;
        sectionHeader.style.margin = "0";

        const backButton = document.createElement("a");
        backButton.href = "#";
        backButton.textContent = "â†‘ Back to top";
        backButton.style.textDecoration = "none";
        backButton.style.color = "#007acc";
        backButton.style.fontSize = "0.8em";
        backButton.style.padding = "0.3em 0.8em";
        backButton.style.border = "1px solid #ccc";
        backButton.style.borderRadius = "4px";
        backButton.style.backgroundColor = "#f9f9f9";
        backButton.addEventListener("mouseover", () => {
          backButton.style.backgroundColor = "#e6e6e6";
        });
        backButton.addEventListener("mouseout", () => {
          backButton.style.backgroundColor = "#f9f9f9";
        });
        backButton.addEventListener("click", (e) => {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: "smooth" });
        });

        headerContainer.appendChild(sectionHeader);
        headerContainer.appendChild(backButton);
        container.appendChild(headerContainer);
        // Create table for the section with three columns: target, description, content
        const table = document.createElement("table");
        table.style.width = "95%";
        // Molecule count row, if present
        if (sectionData.molecule_count !== undefined) {
          const tr = document.createElement("tr");
          const tdTarget = document.createElement("th");
          tdTarget.textContent = "-";
          tdTarget.style.width = "1px";
          const tdDesc = document.createElement("th");
          tdDesc.textContent = "molecule count";
          tdDesc.style.width = "1px";
          const tdContent = document.createElement("td");
          tdContent.textContent = render_number(sectionData.molecule_count);
          tr.appendChild(tdTarget);
          tr.appendChild(tdDesc);
          tr.appendChild(tdContent);
          table.appendChild(tr);
        }
        // For each target (read1, read2, index1, index2)
        ["read1", "read2", "index1", "index2"].forEach((target) => {
          const rows = [];
          if (sectionData[target]) {
            // Add base_statistics summary rows if present
            if (sectionData[target].base_statistics) {
              const bs = sectionData[target].base_statistics;
              if (bs.total_bases !== undefined) {
                const tr = document.createElement("tr");
                const tdDesc = document.createElement("th");
                tdDesc.textContent = "Total bases";
                const tdContent = document.createElement("td");
                tdContent.textContent = render_number(bs.total_bases);
                tr.appendChild(tdDesc);
                tr.appendChild(tdContent);
                rows.push(tr);
              }
              if (bs.gc_bases !== undefined && bs.total_bases) {
                const rel =
                  ((bs.gc_bases / bs.total_bases) * 100).toFixed(2) + "%";
                const tr = document.createElement("tr");
                const tdDesc = document.createElement("th");
                tdDesc.textContent = "GC bases";
                const tdContent = document.createElement("td");
                tdContent.textContent = render_number(bs.gc_bases) + " (" + rel + ")";
                tr.appendChild(tdDesc);
                tr.appendChild(tdContent);
                rows.push(tr);
              }
              if (bs.q20_bases !== undefined && bs.total_bases) {
                const rel =
                  ((bs.q20_bases / bs.total_bases) * 100).toFixed(2) + "%";
                const tr = document.createElement("tr");
                const tdDesc = document.createElement("th");
                tdDesc.textContent = "Q20 bases";
                const tdContent = document.createElement("td");
                tdContent.textContent = render_number(bs.q20_bases) + " (" + rel + ")";
                tr.appendChild(tdDesc);
                tr.appendChild(tdContent);
                rows.push(tr);
              }
              if (bs.q30_bases !== undefined && bs.total_bases) {
                const rel =
                  ((bs.q30_bases / bs.total_bases) * 100).toFixed(2) + "%";
                const tr = document.createElement("tr");
                const tdDesc = document.createElement("th");
                tdDesc.textContent = "Q30 bases";
                const tdContent = document.createElement("td");
                tdContent.textContent = render_number(bs.q30_bases) + " (" + rel + ")";
                tr.appendChild(tdDesc);
                tr.appendChild(tdContent);
                rows.push(tr);
              }
            }
            if (sectionData[target].duplicate_count !== undefined) {
              const dup = sectionData[target].duplicate_count;
              let dupRel = "";
              if (
                sectionData.molecule_count !== undefined &&
                sectionData.molecule_count > 0
              ) {
                dupRel =
                  " (" +
                  ((dup / sectionData.molecule_count) * 100).toFixed(2) +
                  "%)";
              }
              const tr = document.createElement("tr");
              const tdDesc = document.createElement("th");
              tdDesc.textContent = "Duplicate count";
              const tdContent = document.createElement("td");
              tdContent.textContent = render_number(dup) + dupRel;
              tr.appendChild(tdDesc);
              tr.appendChild(tdContent);
              rows.push(tr);
            }
          }
          if (sectionData[target] && sectionData[target].length_distribution) {
            const tr = document.createElement("tr");
            const tdDesc = document.createElement("th");
            tdDesc.textContent = "Read length distribution";
            const tdContent = document.createElement("td");
            plot_read_length_distribution(
              sectionData[target].length_distribution,
              tdContent,
            );
            tr.appendChild(tdDesc);
            tr.appendChild(tdContent);
            rows.push(tr);
          }
          if (sectionData[target] && sectionData[target].base_statistics) {
            if (sectionData[target].base_statistics.per_position_counts) {
              const tr = document.createElement("tr");
              const tdDesc = document.createElement("th");
              tdDesc.textContent = "Per position counts";
              const tdContent = document.createElement("td");
              plot_per_position_counts(
                sectionData[target].base_statistics.per_position_counts,
                tdContent,
              );
              tr.appendChild(tdDesc);
              tr.appendChild(tdContent);
              rows.push(tr);
            }
            if (
              sectionData[target].base_statistics
                .expected_errors_from_quality_curve
            ) {
              const tr = document.createElement("tr");
              const tdDesc = document.createElement("th");
              tdDesc.textContent = "Expected Errors from Quality Curve";
              const tdContent = document.createElement("td");
              plot_expected_errors_from_quality_curve(
                sectionData[target].base_statistics
                  .expected_errors_from_quality_curve,
                tdContent,
              );
              tr.appendChild(tdDesc);
              tr.appendChild(tdContent);
              rows.push(tr);
            }
          }
          if (rows.length > 0) {
            const firstRow = rows[0];
            const tdTarget = document.createElement("th");
            tdTarget.textContent = target;
            tdTarget.style.width = "1px";
            tdTarget.rowSpan = rows.length;
            firstRow.insertBefore(tdTarget, firstRow.firstChild);
            rows.forEach((r) => table.appendChild(r));
          }
        });

        // Check for histogram data under the "histogram" key
        if (sectionData.histogram) {
          for (const [histogramName, histogramData] of Object.entries(sectionData.histogram)) {
            const tr = document.createElement("tr");
            const tdTarget = document.createElement("th");
            tdTarget.textContent = "-";
            tdTarget.style.width = "1px";
            const tdDesc = document.createElement("th");
            tdDesc.textContent = `Histogram: ${histogramName}`;
            tdDesc.style.width = "1px";
            const tdContent = document.createElement("td");
            plot_tag_histogram(histogramData, tdContent);
            tr.appendChild(tdTarget);
            tr.appendChild(tdDesc);
            tr.appendChild(tdContent);
            table.appendChild(tr);
          }
        }
        container.appendChild(table);
        container.appendChild(document.createElement("hr"));
      }

      window.addEventListener("resize", function () {
        //toggel background color between white and blue
        //resize all canvases to 85% width
        document.querySelectorAll("canvas").forEach((canvas) => {
          canvas.style.width = "85%";
        });
      });

      // Fetch data and generate charts on page load
      document.addEventListener("DOMContentLoaded", function () {
        // Add GitHub link if repository is available
        if (embeddedData.__ && embeddedData.__.repository) {
          const githubLink = document.getElementById("github-link");
          githubLink.href = embeddedData.__.repository;
          githubLink.style.display = "block";
        }

        addHead(embeddedData);
        // Use report_order to maintain the order defined in TOML, fallback to Object.keys for backward compatibility
        const reportOrder =
          embeddedData.report_order ||
          Object.keys(embeddedData).filter(
            (key) =>
              key !== "__" && key !== "run_info" && key !== "report_order",
          );

        // Add navigation links if multiple reports are present
        addNavigationLinks(reportOrder);

        reportOrder.forEach((key) => {
          if (
            key !== "__" &&
            key !== "run_info" &&
            key !== "report_order" &&
            embeddedData[key]
          ) {
            addSection(key, embeddedData[key]);
          }
        });
      });

      const embeddedData = "%DATA%";
    </script>
    <script type="module">
      /*%CHART%*/
    </script>
    <style type="text/css">
      body {
        position: relative;
      }
      .github-corner {
        position: fixed;
        top: 0;
        right: 0;
        z-index: 1000;
      }
      .github-corner svg {
        fill: #151513;
        color: #fff;
        position: absolute;
        top: 0;
        border: 0;
        right: 0;
      }
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
      @keyframes octocat-wave {
        0%,
        100% {
          transform: rotate(0);
        }
        20%,
        60% {
          transform: rotate(-25deg);
        }
        40%,
        80% {
          transform: rotate(10deg);
        }
      }
      @media (max-width: 500px) {
        .github-corner:hover .octo-arm {
          animation: none;
        }
        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
      }
      table {
        border-collapse: collapse;
        width: 95%;
      }
      th {
        text-align: left;
        vertical-align: top;
        padding: 0.5em;
      }
      tr {
        border-bottom: 1px dashed #777;
      }
      td {
        text-align: right;
        vertical-align: top;
        padding: 0.5em;
      }

      tr:nth-child(odd) {
        background-color: #dfdfdf;
      }
    </style>
  </head>
  <body>
    <a id="github-link" class="github-corner" aria-label="View source on GitHub" style="display: none;">
      <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
      </svg>
    </a>
    <div id="charts-container"></div>
    <p>
      This chart is made with
      <a href="https://www.chartjs.org/">Chart.js</a> (<a
        href="https://github.com/chartjs/Chart.js?tab=MIT-1-ov-file#readme"
        >MIT License</a
      >).
    </p>
  </body>
</html>
