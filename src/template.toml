# mbf-fastq-processor Configuration Template for LLM Generation
# This template is optimized for Large Language Models to generate valid configurations

# =============================================================================
# CONFIGURATION STRUCTURE (3 Required Sections)
# =============================================================================
# 1. [input]           - Define input files (REQUIRED)
# 2. [[step]]          - Processing pipeline steps (0 or more, order matters)
# 3. [output]          - Output configuration (REQUIRED)
# Optional: [options], [barcodes.*]

# =============================================================================
# QUICK START PATTERNS (Copy and modify these common use cases)
# =============================================================================

# PATTERN 1: Basic Quality Report (no transformation)
# [input]
#     read1 = ['sample.fastq.gz']
# [[step]]
#     action = 'Report'
#     name = 'quality_check'
#     count = true
#     base_statistics = true
#     length_distribution = true
# [output]
#     prefix = 'output'
#     report_html = true
#     report_json = true
#     format = "None"  # No sequence output, just reports

# PATTERN 2: UMI Extraction and Trimming
# [input]
#     read1 = ['sample_R1.fastq.gz']
#     read2 = ['sample_R2.fastq.gz']
# [[step]]
#     action = 'ExtractRegion'
#     segment = 'read1'
#     start = 0
#     len = 8
#     out_label = 'umi'
# [[step]]
#     action = 'StoreTagInComment'
#     in_label = 'umi'
# [[step]]
#     action = 'CutStart'
#     segment = 'read1'
#     n = 8
# [output]
#     prefix = 'output'
#     format = "Fastq"
#     compression = "Gzip"

# PATTERN 3: Adapter Trimming
# [input]
#     read1 = ['sample.fastq.gz']
# [[step]]
#     action = 'ExtractIUPACSuffix'
#     segment = 'read1'
#     query = 'AGATCGGAAGAGC'
#     min_length = 3
#     max_mismatches = 1
#     out_label = 'adapter'
# [[step]]
#     action = 'TrimAtTag'
#     in_label = 'adapter'
#     direction = 'End'
#     keep_tag = false
# [output]
#     prefix = 'output'
#     format = "Fastq"
#     compression = "Gzip"

# PATTERN 4: Quality Filtering
# [input]
#     read1 = ['sample.fastq.gz']
# [[step]]
#     action = 'CalcQualifiedBases'
#     segment = 'read1'
#     threshold = 'C'
#     op = 'below'
#     out_label = 'high_quality_bases'
# [[step]]
#     action = 'FilterByNumericTag'
#     in_label = 'high_quality_bases'
#     min_value = 100.0
#     keep_or_remove = 'Keep'
# [output]
#     prefix = 'output'
#     format = "Fastq"
#     compression = "Gzip"

# PATTERN 5: Demultiplexing by Barcode
# [input]
#     read1 = ['sample_R1.fastq.gz']
#     index1 = ['sample_I1.fastq.gz']
# [[step]]
#     action = 'ExtractRegion'
#     segment = 'index1'
#     start = 0
#     len = 8
#     out_label = 'barcode'
# [[step]]
#     action = 'HammingCorrect'
#     in_label = 'barcode'
#     out_label = 'barcode_corrected'
#     barcodes = 'my_barcodes'
#     max_hamming_distance = 1
#     on_no_match = 'remove'
# [[step]]
#     action = 'Demultiplex'
#     in_label = 'barcode_corrected'
#     barcodes = 'my_barcodes'
#     output_unmatched = true
# [barcodes.my_barcodes]
#     'AAAAAAAA' = 'sample_1'
#     'CCCCCCCC' = 'sample_2'
#     'GGGGGGGG' = 'sample_3'
# [output]
#     prefix = 'output'
#     format = "Fastq"
#     compression = "Gzip"

# =============================================================================
# SECTION 1: INPUT (REQUIRED)
# =============================================================================
[input]
# TYPE: object with keys: read1, read2?, index1?, index2?, interleaved?, options?
# REQUIRED: At least one of: read1, interleaved
# CONSTRAINT: All file lists must have the same length

# Standard segments (choose one or more):
read1 = ['file1_R1.fastq', 'file2_R1.fastq.gz', 'file3_R1.fastq.zstd']  # REQUIRED (unless using interleaved)
# read2 = ['file1_R2.fastq']      # OPTIONAL: for paired-end reads
# index1 = ['file1_I1.fastq']     # OPTIONAL: for index/barcode reads
# index2 = ['file1_I2.fastq']     # OPTIONAL: for dual-index reads

# Interleaved mode (alternative to separate read1/read2):
# interleaved = ['read1', 'read2']  # Specify segment names for interleaved data
# read12 = ['interleaved.fastq']    # Then specify the file(s)

# Supported file formats (auto-detected):
# - FASTQ (.fq, .fastq, .fq.gz, .fastq.gz, .fq.zst, .fastq.zst)
# - FASTA (.fa, .fasta, .fa.gz, etc.) - requires fasta_fake_quality
# - BAM (.bam) - requires bam_include_mapped and/or bam_include_unmapped

[input.options]
# OPTIONAL: Additional input configuration
# fasta_fake_quality = 30           # TYPE: u8 (0-93), REQUIRED for FASTA input
# bam_include_mapped = true         # TYPE: bool, REQUIRED for BAM input
# bam_include_unmapped = true       # TYPE: bool, REQUIRED for BAM input
# read_comment_char = ' '           # TYPE: char, DEFAULT: ' '

# =============================================================================
# SECTION 2: PROCESSING STEPS (OPTIONAL, ORDER MATTERS)
# =============================================================================
# Each [[step]] is executed in order on the data stream
# Steps are grouped by category for easy reference

# -----------------------------------------------------------------------------
# CATEGORY: EXTRACTION - Create tags from sequences
# -----------------------------------------------------------------------------
# Use these to identify and label parts of sequences
# All create "tags" stored with label specified by 'out_label'
# Tags can be: location-based (regions), numeric (scores), or boolean (flags)

# STEP: ExtractRegion - Extract fixed position
# USE WHEN: You know exact base positions (e.g., UMI at bases 0-7)
# [[step]]
#     action = 'ExtractRegion'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     start = 0                      # TYPE: usize, REQUIRED, 0-indexed
#     len = 8                        # TYPE: usize, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED, must be unique

# STEP: ExtractRegions - Extract multiple fixed positions
# USE WHEN: Barcode split across multiple positions (e.g., bases 0-7 and 12-19)
# [[step]]
#     action = 'ExtractRegions'
#     regions = [                    # TYPE: array of objects, REQUIRED
#         {segment = 'read1', start = 0, length = 8},
#         {segment = 'read1', start = 12, length = 8}
#     ]
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractIUPAC - Find IUPAC pattern (substitutions only)
# USE WHEN: Searching for adapter/motif with mismatches (no indels)
# IUPAC codes: N=any, R=A/G, Y=C/T, S=G/C, W=A/T, K=G/T, M=A/C, etc.
# [[step]]
#     action = 'ExtractIUPAC'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     search = 'CTNNGG'              # TYPE: IUPAC string, REQUIRED
#     max_mismatches = 1             # TYPE: usize, REQUIRED
#     anchor = 'Anywhere'            # TYPE: 'Left'|'Right'|'Anywhere', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractIUPACWithIndel - Find IUPAC pattern (with insertions/deletions)
# USE WHEN: Searching with indels allowed (slower than ExtractIUPAC)
# [[step]]
#     action = 'ExtractIUPACWithIndel'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     search = 'CTNNGG'              # TYPE: IUPAC string, REQUIRED
#     max_mismatches = 1             # TYPE: usize, REQUIRED
#     max_indel_bases = 1            # TYPE: usize, REQUIRED
#     anchor = 'Anywhere'            # TYPE: 'Left'|'Right'|'Anywhere', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # max_total_edits = 2          # TYPE: usize, OPTIONAL

# STEP: ExtractIUPACSuffix - Trim adapter at end (partial matches OK)
# USE WHEN: Trimming 3' adapters that may be partially present
# [[step]]
#     action = 'ExtractIUPACSuffix'
#     segment = 'read1'              # TYPE: segment name, DEFAULT: 'read1'
#     query = 'AGATCGGAAGAGC'        # TYPE: DNA string (AGTCN only), REQUIRED
#     min_length = 3                 # TYPE: usize, REQUIRED, min bases to match
#     max_mismatches = 1             # TYPE: usize, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractRegex - Extract using regular expression
# USE WHEN: Complex pattern matching needed
# [[step]]
#     action = 'ExtractRegex'
#     search = '^CT(..)CT'           # TYPE: regex string, REQUIRED
#     replacement = '$1'             # TYPE: string, REQUIRED, use $1, $2 for groups
#     source = 'read1'               # TYPE: segment name or 'name:<segment>', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractAnchor - Extract relative to another tag
# USE WHEN: Extracting regions relative to a found motif
# REQUIRES: Another tag created first as anchor
# [[step]]
#     action = 'ExtractAnchor'
#     in_label = 'anchor_tag'        # TYPE: existing tag name, REQUIRED
#     regions = [[-2, 4], [4, 1]]    # TYPE: [[start, length], ...], REQUIRED
#     region_separator = '_'         # TYPE: string, DEFAULT: '_'
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractLowQualityStart - Find low-quality bases at start
# USE WHEN: Quality-based trimming from 5' end
# [[step]]
#     action = 'ExtractLowQualityStart'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     min_qual = 'C'                 # TYPE: char (Phred+33), REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractLowQualityEnd - Find low-quality bases at end
# USE WHEN: Quality-based trimming from 3' end
# [[step]]
#     action = 'ExtractLowQualityEnd'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     min_qual = 'C'                 # TYPE: char (Phred+33), REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractRegionsOfLowQuality - Find all low-quality regions
# USE WHEN: Identifying quality issues anywhere in read
# [[step]]
#     action = 'ExtractRegionsOfLowQuality'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     min_quality = 60               # TYPE: u8, REQUIRED, ASCII value (e.g., 60='<', Phred=27)
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractPolyTail - Find homopolymer tail
# USE WHEN: Removing polyA/T/G/C/N tails (e.g., polyA tails in RNA-seq)
# [[step]]
#     action = 'ExtractPolyTail'
#     segment = 'read1'              # TYPE: segment name, DEFAULT: 'read1'
#     base = 'A'                     # TYPE: 'A'|'T'|'G'|'C'|'N'|'.', REQUIRED ('.' = any base)
#     min_length = 5                 # TYPE: usize, REQUIRED
#     max_mismatch_rate = 0.1        # TYPE: float (0.0-1.0), REQUIRED
#     max_consecutive_mismatches = 3 # TYPE: usize, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: ExtractLongestPolyX - Find longest homopolymer anywhere
# USE WHEN: Detecting internal homopolymer runs
# [[step]]
#     action = 'ExtractLongestPolyX'
#     segment = 'read1'              # TYPE: segment name, DEFAULT: 'read1'
#     base = '.'                     # TYPE: 'A'|'T'|'G'|'C'|'N'|'.', REQUIRED ('.' = longest of any)
#     min_length = 5                 # TYPE: usize, REQUIRED
#     max_mismatch_rate = 0.1        # TYPE: float (0.0-1.0), REQUIRED
#     max_consecutive_mismatches = 3 # TYPE: usize, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# -----------------------------------------------------------------------------
# CATEGORY: NUMERIC TAGS - Calculate metrics
# -----------------------------------------------------------------------------
# Create numeric tags for filtering or analysis

# STEP: CalcLength - Calculate sequence length
# [[step]]
#     action = 'CalcLength'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcGCContent - Calculate GC percentage
# [[step]]
#     action = 'CalcGCContent'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcBaseContent - Calculate custom base percentage
# [[step]]
#     action = 'CalcBaseContent'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     bases_to_count = 'AT'          # TYPE: string, REQUIRED
#     relative = true                # TYPE: bool, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # bases_to_ignore = 'N'        # TYPE: string, OPTIONAL (only with relative=true)

# STEP: CalcNCount - Count N bases
# [[step]]
#     action = 'CalcNCount'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcQualifiedBases - Count high/low quality bases
# [[step]]
#     action = 'CalcQualifiedBases'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     threshold = 'C'                # TYPE: char (Phred+33), REQUIRED
#     op = 'below'                   # TYPE: 'below'|'above'|'<'|'>'|'<='|'>=', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcExpectedError - Aggregate error probabilities
# [[step]]
#     action = 'CalcExpectedError'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     aggregate = 'sum'              # TYPE: 'sum'|'max', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcComplexity - Calculate sequence complexity
# USE WHEN: Filtering low-complexity sequences
# [[step]]
#     action = 'CalcComplexity'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: CalcKmers - Count matching k-mers from reference
# USE WHEN: Filtering contamination or specific sequences
# [[step]]
#     action = 'CalcKmers'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     files = ['reference.fa']       # TYPE: array of file paths, REQUIRED
#     k = 21                         # TYPE: usize, REQUIRED
#     count_reverse_complement = true # TYPE: bool, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # min_count = 2                # TYPE: usize, DEFAULT: 1

# STEP: ConvertRegionsToLength - Convert region tag to length
# USE WHEN: You need numeric length from a region tag
# [[step]]
#     action = 'ConvertRegionsToLength'
#     in_label = 'region_tag'        # TYPE: existing region tag, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# STEP: EvalExpression - Calculate arithmetic expression
# USE WHEN: Combining multiple tags with math
# OPERATORS: +, -, *, /, %, ^, log(base, val), min(), max(), abs(), etc.
# [[step]]
#     action = 'EvalExpression'
#     expression = 'gc_content >= 0.4 && length > 50'  # TYPE: string, REQUIRED
#     result_type = 'bool'           # TYPE: 'bool'|'numeric', REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED

# -----------------------------------------------------------------------------
# CATEGORY: BOOLEAN TAGS - Mark reads
# -----------------------------------------------------------------------------

# STEP: TagDuplicates - Mark duplicate reads
# USE WHEN: Identifying PCR duplicates
# [[step]]
#     action = 'TagDuplicates'
#     source = 'read1'               # TYPE: segment|'All'|'tag:<name>'|'name:<segment>', REQUIRED
#     false_positive_rate = 0.01     # TYPE: float (0.0-1.0), REQUIRED (0 = exact)
#     seed = 42                      # TYPE: u64, REQUIRED (if FPR > 0)
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # split_character = '/'        # TYPE: char, REQUIRED if using 'name:<segment>'

# STEP: TagOtherFileByName - Mark reads present in another file
# [[step]]
#     action = 'TagOtherFileByName'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     filename = 'names.fastq'       # TYPE: file path, REQUIRED
#     false_positive_rate = 0.01     # TYPE: float (0.0-1.0), REQUIRED
#     seed = 42                      # TYPE: u64, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # ignore_unaligned = false     # TYPE: bool, DEFAULT: false (for BAM/SAM)
#     # fastq_readname_end_char = ' '   # TYPE: char, OPTIONAL
#     # reference_readname_end_char = '/' # TYPE: char, OPTIONAL

# STEP: TagOtherFileBySequence - Mark reads with sequences in another file
# [[step]]
#     action = 'TagOtherFileBySequence'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     filename = 'sequences.fastq'   # TYPE: file path, REQUIRED
#     false_positive_rate = 0.01     # TYPE: float (0.0-1.0), REQUIRED
#     seed = 42                      # TYPE: u64, REQUIRED
#     out_label = 'tag_name'         # TYPE: string, REQUIRED
#     # ignore_unaligned = false     # TYPE: bool, DEFAULT: false

# -----------------------------------------------------------------------------
# CATEGORY: FILTERING - Remove reads
# -----------------------------------------------------------------------------
# keep_or_remove: 'Keep' = keep matching reads, 'Remove' = remove matching reads

# STEP: FilterByTag - Filter by presence of location tag
# [[step]]
#     action = 'FilterByTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     keep_or_remove = 'Keep'        # TYPE: 'Keep'|'Remove', REQUIRED

# STEP: FilterByNumericTag - Filter by numeric value
# [[step]]
#     action = 'FilterByNumericTag'
#     in_label = 'tag_name'          # TYPE: existing numeric tag, REQUIRED
#     keep_or_remove = 'Keep'        # TYPE: 'Keep'|'Remove', REQUIRED
#     # min_value = 0.0              # TYPE: float, OPTIONAL (at least one of min/max required)
#     # max_value = 100.0            # TYPE: float, OPTIONAL (exclusive)

# STEP: FilterEmpty - Remove empty reads
# [[step]]
#     action = 'FilterEmpty'
#     segment = 'All'                # TYPE: segment name or 'All', REQUIRED

# STEP: Head - Keep first N reads
# [[step]]
#     action = 'Head'
#     n = 1000                       # TYPE: usize, REQUIRED

# STEP: Skip - Skip first N reads
# [[step]]
#     action = 'Skip'
#     n = 100                        # TYPE: usize, REQUIRED

# STEP: FilterSample - Random sampling by probability
# [[step]]
#     action = 'FilterSample'
#     p = 0.1                        # TYPE: float (0.0-1.0), REQUIRED
#     # seed = 42                    # TYPE: u64, OPTIONAL

# STEP: FilterReservoirSample - Random sampling exact count
# [[step]]
#     action = 'FilterReservoirSample'
#     n = 10000                      # TYPE: usize, REQUIRED
#     # seed = 42                    # TYPE: u64, OPTIONAL

# -----------------------------------------------------------------------------
# CATEGORY: SEQUENCE MODIFICATION - Edit sequences
# -----------------------------------------------------------------------------

# STEP: TrimAtTag - Trim at tag position
# USE AFTER: ExtractIUPACSuffix, ExtractLowQualityEnd, etc.
# [[step]]
#     action = 'TrimAtTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     direction = 'End'              # TYPE: 'Start'|'End', REQUIRED
#     keep_tag = false               # TYPE: bool, REQUIRED

# STEP: CutStart - Remove N bases from start
# [[step]]
#     action = 'CutStart'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     n = 5                          # TYPE: usize, REQUIRED

# STEP: CutEnd - Remove N bases from end
# [[step]]
#     action = 'CutEnd'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     n = 10                         # TYPE: usize, REQUIRED

# STEP: Truncate - Limit maximum length
# [[step]]
#     action = 'Truncate'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     n = 150                        # TYPE: usize, REQUIRED

# STEP: Prefix - Add bases to start
# [[step]]
#     action = 'Prefix'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     seq = 'AGTC'                   # TYPE: DNA string (agtcn), REQUIRED
#     qual = 'IIII'                  # TYPE: quality string (same length as seq), REQUIRED

# STEP: Postfix - Add bases to end
# [[step]]
#     action = 'Postfix'
#     segment = 'read1'              # TYPE: segment name, REQUIRED
#     seq = 'AGTC'                   # TYPE: DNA string (agtcn), REQUIRED
#     qual = 'IIII'                  # TYPE: quality string (same length as seq), REQUIRED

# STEP: ReplaceTagWithLetter - Replace tag regions with letter
# USE WHEN: Masking low-quality regions as 'N'
# [[step]]
#     action = 'ReplaceTagWithLetter'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     letter = 'N'                   # TYPE: char, DEFAULT: 'N'

# STEP: StoreTagInSequence - Replace sequence with tag content
# [[step]]
#     action = 'StoreTagInSequence'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     ignore_missing = true          # TYPE: bool, REQUIRED

# STEP: ReverseComplement - Reverse complement a segment
# [[step]]
#     action = 'ReverseComplement'
#     segment = 'read1'              # TYPE: segment name, REQUIRED

# STEP: ReverseComplementConditional - Conditionally reverse complement
# [[step]]
#     action = 'ReverseComplementConditional'
#     in_label = 'bool_tag'          # TYPE: existing boolean tag, REQUIRED
#     segment = 'read1'              # TYPE: segment name, DEFAULT: 'read1'

# STEP: MergeReads - Merge overlapping paired reads
# USE WHEN: Merging R1/R2 with overlap (e.g., short amplicons)
# [[step]]
#     action = 'MergeReads'
#     segment1 = 'read1'             # TYPE: segment name, DEFAULT: 'read1'
#     segment2 = 'read2'             # TYPE: segment name, DEFAULT: 'read2'
#     reverse_complement_segment2 = true  # TYPE: bool, REQUIRED
#     algorithm = 'FastpSeemsWeird'  # TYPE: string, REQUIRED
#     min_overlap = 30               # TYPE: usize, REQUIRED
#     max_mismatch_rate = 0.2        # TYPE: float (0.0-1.0), OPTIONAL
#     max_mismatch_count = 5         # TYPE: usize, OPTIONAL (at least one of rate/count required)
#     no_overlap_strategy = 'as_is' # TYPE: 'as_is'|'concatenate', REQUIRED
#     # out_label = 'merged'         # TYPE: string, OPTIONAL (creates boolean tag)
#     # concatenate_spacer = 'NNNN'  # TYPE: string, REQUIRED if strategy='concatenate'
#     # spacer_quality_char = 33     # TYPE: u8, DEFAULT: 33

# STEP: Swap - Swap two segments
# [[step]]
#     action = 'Swap'
#     segment_a = 'read1'            # TYPE: segment name, REQUIRED
#     segment_b = 'read2'            # TYPE: segment name, REQUIRED

# STEP: SwapConditional - Conditionally swap segments
# [[step]]
#     action = 'SwapConditional'
#     in_label = 'bool_tag'          # TYPE: existing boolean tag, REQUIRED
#     # segment_a = 'read1'          # TYPE: segment name, OPTIONAL (needed if >2 segments)
#     # segment_b = 'read2'          # TYPE: segment name, OPTIONAL

# STEP: LowercaseSequence - Convert sequence to lowercase
# [[step]]
#     action = 'LowercaseSequence'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED

# STEP: UppercaseSequence - Convert sequence to uppercase
# [[step]]
#     action = 'UppercaseSequence'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED

# STEP: LowercaseTag - Convert tag to lowercase
# [[step]]
#     action = 'LowercaseTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED

# STEP: UppercaseTag - Convert tag to uppercase
# [[step]]
#     action = 'UppercaseTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED

# STEP: Rename - Rename reads with regex
# [[step]]
#     action = 'Rename'
#     search = 'read_(.+)'           # TYPE: regex string, REQUIRED
#     replacement = 'READ_$1'        # TYPE: string, REQUIRED (use $1, $2, {{READ_INDEX}})

# STEP: ConvertQuality - Convert quality encoding
# [[step]]
#     action = 'ConvertQuality'
#     from = 'Illumina1.8'           # TYPE: 'Illumina1.8'|'Illumina1.3'|'Sanger'|'Solexa', REQUIRED
#     to = 'Sanger'                  # TYPE: same as 'from', REQUIRED (must differ)

# -----------------------------------------------------------------------------
# CATEGORY: TAG STORAGE - Save tags to output
# -----------------------------------------------------------------------------

# STEP: StoreTagInComment - Store tag in read name comment
# USE WHEN: Preserving tags through alignment (e.g., UMIs for STAR)
# [[step]]
#     action = 'StoreTagInComment'
#     segment = 'read1'              # TYPE: segment name or 'All', DEFAULT: 'read1'
#     # in_label = 'tag_name'        # TYPE: string, OPTIONAL (omit to store all tags)
#     # comment_insert_char = ' '    # TYPE: char, DEFAULT: ' '
#     # comment_separator = '|'      # TYPE: char, DEFAULT: '|'
#     # region_separator = '_'       # TYPE: char, DEFAULT: '_'

# STEP: StoreTagLocationInComment - Store tag coordinates in comment
# [[step]]
#     action = 'StoreTagLocationInComment'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     segment = 'read1'              # TYPE: segment name or 'All', DEFAULT: 'read1'
#     # comment_insert_char = ' '    # TYPE: char, DEFAULT: ' '
#     # comment_separator = '|'      # TYPE: char, DEFAULT: '|'

# STEP: StoreTagInFastQ - Save tag to separate FASTQ file
# [[step]]
#     action = 'StoreTagInFastQ'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     compression = 'Gzip'           # TYPE: 'Raw'|'Gzip'|'Zstd', REQUIRED
#     # compression_level = 6        # TYPE: usize, OPTIONAL (gzip: 0-9, zstd: 1-22)
#     # comment_tags = []            # TYPE: array of tag names, DEFAULT: []
#     # comment_location_tags = ['tag_name']  # TYPE: array, DEFAULT: [in_label]
#     # comment_insert_char = ' '    # TYPE: char, DEFAULT: ' '
#     # comment_separator = '|'      # TYPE: char, DEFAULT: '|'
#     # region_separator = '_'       # TYPE: char, DEFAULT: '_'

# STEP: StoreTagsInTable - Save all tags to TSV
# [[step]]
#     action = 'StoreTagsInTable'
#     infix = 'tags'                 # TYPE: string, REQUIRED (output: prefix_infix.tsv)
#     compression = 'Raw'            # TYPE: 'Raw'|'Gzip'|'Zstd', REQUIRED
#     # region_separator = '_'       # TYPE: char, DEFAULT: '_'
#     # in_labels = ['tag1', 'tag2'] # TYPE: array, OPTIONAL (omit for all tags)

# STEP: QuantifyTag - Count tag occurrences
# [[step]]
#     action = 'QuantifyTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED
#     infix = 'tagcount'             # TYPE: string, REQUIRED (output: prefix_infix.qr.json)

# -----------------------------------------------------------------------------
# CATEGORY: BARCODE CORRECTION & DEMULTIPLEXING
# -----------------------------------------------------------------------------

# STEP: HammingCorrect - Correct barcodes by Hamming distance
# USE BEFORE: Demultiplex or FilterByTag
# [[step]]
#     action = 'HammingCorrect'
#     in_label = 'barcode_tag'       # TYPE: existing tag, REQUIRED
#     out_label = 'corrected_tag'    # TYPE: string, REQUIRED
#     barcodes = 'barcode_list_name' # TYPE: string, REQUIRED (see [barcodes.*] section)
#     max_hamming_distance = 1       # TYPE: usize, REQUIRED
#     on_no_match = 'remove'         # TYPE: 'remove'|'keep'|'empty', REQUIRED

# STEP: Demultiplex - Split output by barcode
# USE AFTER: HammingCorrect (usually)
# CREATES: Separate output files per barcode
# [[step]]
#     action = 'Demultiplex'
#     in_label = 'barcode_tag'       # TYPE: existing tag or boolean tag, REQUIRED
#     output_unmatched = true        # TYPE: bool, REQUIRED
#     # barcodes = 'barcode_list_name'  # TYPE: string, OPTIONAL (omit for boolean tags)

# Barcode definitions (referenced by HammingCorrect and Demultiplex):
# [barcodes.barcode_list_name]
#     'AAAAAAAA' = 'sample_1'        # barcode -> output_name
#     'CCCCCCCC' = 'sample_2'
#     'GGGGGGGG' = 'sample_1'        # Multiple barcodes can map to same sample

# -----------------------------------------------------------------------------
# CATEGORY: VALIDATION - Check data quality
# -----------------------------------------------------------------------------

# STEP: ValidateQuality - Check quality scores in valid range
# [[step]]
#     action = 'ValidateQuality'
#     segment = 'All'                # TYPE: segment name or 'All', REQUIRED
#     encoding = 'Illumina1.8'       # TYPE: 'Illumina1.8'|'Illumina1.3'|'Sanger'|'Solexa', REQUIRED

# STEP: ValidateSeq - Check sequences contain only allowed bases
# [[step]]
#     action = 'ValidateSeq'
#     segment = 'read1'              # TYPE: segment name or 'All', REQUIRED
#     allowed = 'agtcn'              # TYPE: string, REQUIRED (case-sensitive)

# STEP: ValidateName - Check read names match across segments
# [[step]]
#     action = 'ValidateName'
#     # readname_end_char = '/'      # TYPE: char, OPTIONAL (omit for exact match)

# STEP: SpotCheckReadPairing - Sample-based name validation
# [[step]]
#     action = 'SpotCheckReadPairing'
#     # sample_stride = 1000         # TYPE: usize, DEFAULT: 1000
#     # readname_end_char = '/'      # TYPE: char, DEFAULT: '/'

# STEP: ValidateAllReadsSameLength - Check all reads same length
# [[step]]
#     action = 'ValidateAllReadsSameLength'
#     source = 'read1'               # TYPE: segment|'All'|'tag:<name>'|'name:<segment>', REQUIRED

# -----------------------------------------------------------------------------
# CATEGORY: REPORTING & DEBUGGING
# -----------------------------------------------------------------------------

# STEP: Report - Generate quality report
# USE AT: Beginning and/or end of pipeline for before/after comparison
# [[step]]
#     action = 'Report'
#     name = 'step_name'             # TYPE: string, REQUIRED (identifies this report section)
#     count = true                   # TYPE: bool, DEFAULT: false
#     base_statistics = true         # TYPE: bool, DEFAULT: false
#     length_distribution = true     # TYPE: bool, DEFAULT: false
#     duplicate_count_per_read = true # TYPE: bool, DEFAULT: false
#     duplicate_count_per_fragment = true # TYPE: bool, DEFAULT: false
#     # count_oligos = ['AGTC', 'GGGG']  # TYPE: array, OPTIONAL
#     # count_oligos_segment = 'read1'   # TYPE: segment or 'All', REQUIRED if count_oligos set

# STEP: Progress - Report processing progress
# [[step]]
#     action = 'Progress'
#     n = 1000000                    # TYPE: usize, REQUIRED (report every N reads)
#     # output_infix = 'progress'    # TYPE: string, OPTIONAL (write to file instead of stdout)

# STEP: Inspect - Output sample reads for debugging
# [[step]]
#     action = 'Inspect'
#     n = 10                         # TYPE: usize, REQUIRED
#     infix = 'inspection'           # TYPE: string, REQUIRED
#     segment = 'read1'              # TYPE: segment name or 'all', REQUIRED
#     # suffix = 'txt'               # TYPE: string, OPTIONAL
#     # compression = 'Gzip'         # TYPE: 'Raw'|'Gzip'|'Zstd', DEFAULT: 'Raw'
#     # compression_level = 6        # TYPE: usize, OPTIONAL

# -----------------------------------------------------------------------------
# CATEGORY: TAG MANAGEMENT
# -----------------------------------------------------------------------------

# STEP: ForgetTag - Remove a tag from memory
# [[step]]
#     action = 'ForgetTag'
#     in_label = 'tag_name'          # TYPE: existing tag, REQUIRED

# STEP: ForgetAllTags - Remove all tags from memory
# [[step]]
#     action = 'ForgetAllTags'

# =============================================================================
# SECTION 3: OUTPUT (REQUIRED)
# =============================================================================
[output]
# TYPE: object with keys: prefix, format?, compression?, suffix?, etc.
# REQUIRED: prefix
# OUTPUT FILES: {prefix}_{segment}.{suffix}

prefix = 'output'                   # TYPE: string, REQUIRED (base name for output files)
format = 'Fastq'                    # TYPE: 'Fastq'|'Fasta'|'BAM'|'None', DEFAULT: 'Fastq'
compression = 'Gzip'                # TYPE: 'Raw'|'Gzip'|'Zstd', DEFAULT: 'Raw'
# suffix = '.fq.gz'                 # TYPE: string, OPTIONAL (auto-determined if omitted)
# compression_level = 6             # TYPE: usize, OPTIONAL (gzip: 0-9, zstd: 1-22)

# Report generation:
report_json = true                  # TYPE: bool, DEFAULT: false (create {prefix}.json)
report_html = true                  # TYPE: bool, DEFAULT: false (create {prefix}.html)

# Advanced output options:
# stdout = false                    # TYPE: bool, DEFAULT: false (write read1 to stdout)
# interleave = false                # TYPE: bool, DEFAULT: false (interleave R1/R2 in one file)
# keep_index = false                # TYPE: bool, DEFAULT: false (write index files)
# output = ['read1', 'read2']       # TYPE: array, OPTIONAL (which segments to output)
# ix_separator = '_'                # TYPE: string, DEFAULT: '_'
# Chunksize = 1000000               # TYPE: usize, OPTIONAL (split into chunks)
# output_hash_uncompressed = false  # TYPE: bool, DEFAULT: false (create .sha256 files)
# output_hash_compressed = false    # TYPE: bool, DEFAULT: false

# =============================================================================
# SECTION 4: OPTIONS (OPTIONAL)
# =============================================================================
# [options]
# TYPE: object with keys: spot_check_read_pairing?, thread_count?, etc.
# ALL OPTIONAL

# spot_check_read_pairing = true    # TYPE: bool, DEFAULT: true
# thread_count = -1                 # TYPE: i32, DEFAULT: -1 (auto-detect)
# block_size = 10000                # TYPE: usize, DEFAULT: 10000
# buffer_size = 102400              # TYPE: usize, DEFAULT: 102400
# accept_duplicate_files = false    # TYPE: bool, DEFAULT: false

# =============================================================================
# DECISION TREE FOR COMMON TASKS
# =============================================================================
# TASK: Remove adapter sequences
#   → Use ExtractIUPACSuffix + TrimAtTag (for 3' adapters)
#   → Use ExtractIUPAC + TrimAtTag (for 5' or internal adapters)
#
# TASK: Extract and preserve UMIs
#   → Use ExtractRegion/ExtractRegions
#   → Then StoreTagInComment (to preserve through alignment)
#   → Then CutStart/CutEnd (to remove from sequence)
#
# TASK: Quality filtering
#   → Use CalcQualifiedBases + FilterByNumericTag
#   → Or ExtractLowQualityEnd + TrimAtTag
#
# TASK: Length filtering
#   → Use CalcLength + FilterByNumericTag
#   → Or FilterEmpty (for zero-length reads)
#
# TASK: Demultiplex samples
#   → Extract barcode: ExtractRegion or ExtractIUPAC
#   → Correct errors: HammingCorrect
#   → Split files: Demultiplex
#
# TASK: Remove contamination
#   → Use TagOtherFileBySequence (mark contaminants)
#   → Then FilterByTag with keep_or_remove='Remove'
#   → Or use CalcKmers + FilterByNumericTag
#
# TASK: Deduplicate reads
#   → Use TagDuplicates + FilterByTag with keep_or_remove='Remove'
#
# TASK: Merge paired-end reads
#   → Use MergeReads
#
# TASK: Quality report only (no output)
#   → Use Report step(s)
#   → Set output.format = 'None'
#
# TASK: Complex filtering logic
#   → Create multiple numeric tags
#   → Use EvalExpression to combine them
#   → Use FilterByNumericTag on result

# =============================================================================
# VALIDATION RULES FOR LLM GENERATION
# =============================================================================
# 1. [input] section REQUIRED with at least 'read1' or 'interleaved'
# 2. [output] section REQUIRED with at least 'prefix'
# 3. All file lists in [input] must have same length
# 4. Each [[step]] must have valid 'action' field
# 5. Tag names (out_label) must be unique within pipeline
# 6. in_label must reference previously created tag
# 7. segment names must match those defined in [input]
# 8. Barcode references must match [barcodes.*] section names
# 9. Steps execute in order - tags must be created before use
# 10. Some steps are mutually exclusive (check documentation)

# =============================================================================
# COMMON ERRORS TO AVOID
# =============================================================================
# ❌ Using in_label before creating the tag with out_label
# ❌ Referencing non-existent segment names
# ❌ Using FilterByNumericTag on location tags (use FilterByTag)
# ❌ Forgetting to TrimAtTag after ExtractIUPACSuffix
# ❌ Using output.stdout = true with Progress (incompatible)
# ❌ Setting both format='None' and compression (no sequence output)
# ❌ Mismatched file list lengths in [input]
# ❌ Using reserved names or special characters in tag names
# ❌ Applying segment-specific operations to non-existent segments

# =============================================================================
# END OF TEMPLATE
# =============================================================================
