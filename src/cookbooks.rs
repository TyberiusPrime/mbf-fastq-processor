// This file is auto-generated by dev/update_cookbooks.py
// Do not edit manually - changes will be overwritten

pub struct Cookbook {
    pub number: usize,
    pub name: &'static str,
    pub path: &'static str,
    pub readme: &'static str,
    pub toml: &'static str,
}

pub const COOKBOOKS: &[Cookbook] = &[
    Cookbook {
        number: 1,
        name: "01-basic-quality-report",
        path: "01-basic-quality-report",
        readme: r#"# Cookbook 01: Basic Quality Report

## Use Case

You have FastQ files from a sequencing run and want to generate comprehensive quality reports to assess:
- Read quality scores
- Base composition
- Read length distribution
- Duplicate read counts

This is typically the first step in any sequencing data analysis to understand data quality before downstream processing.

## What This Pipeline Does

1. Reads input FastQ file(s)
2. Generates a comprehensive quality report including:
   - Base quality statistics
   - Base distribution across positions
   - Read length distribution
   - Duplicate read counting
3. Outputs reports in both HTML (human-readable) and JSON (machine-readable) formats
4. Passes through all reads unchanged (no filtering)

## Input Files

- `input/sample_R1.fq` - Forward reads (Read 1) from paired-end sequencing

## Output Files

- `output_R1.fq` - Passed-through reads (identical to input)
- `output.report_initial.html` - HTML quality report
- `output.report_initial.json` - JSON quality report with detailed statistics

## When to Use This

- First analysis of new sequencing data
- Quality control before committing to expensive downstream analysis
- Comparing data quality across different sequencing runs
- Identifying potential issues (adapter contamination, quality drop-off, etc.)

"#,
        toml: r#"[input]
    # Single-end reads for this example
    # For paired-end data, you would also include: read2 = 'input/sample_R2.fq'
    read1 = 'input/sample_R1.fq'

[[step]]
    # Generate a comprehensive quality report
    action = 'Report'
    label = 'initial'

    # Count total number of reads
    count = true

    # Analyze base quality scores and GC content
    base_statistics = true

    # Count duplicate reads (identical sequences)
    duplicate_count_per_read = true

    # Analyze the distribution of read lengths
    length_distribution = true

[output]
    # Output prefix for all files
    prefix = 'output'

    # Generate both HTML and JSON reports
    report_html = true
    report_json = true

    # Output format (FASTQ = uncompressed FASTQ format)
    format = \"FASTQ\"
"#,
    },
    Cookbook {
        number: 2,
        name: "02-umi-extraction",
        path: "02-umi-extraction",
        readme: r#"# Cookbook 02: UMI Extraction

## Use Case

You have sequencing data with Unique Molecular Identifiers (UMIs) embedded in the reads. UMIs are short random barcodes added during library preparation that allow you to:
- Identify and remove PCR duplicates
- Distinguish true biological duplicates from amplification artifacts
- Improve accuracy in quantitative analyses (RNA-seq, ATAC-seq, etc.)

## What This Pipeline Does

1. Reads input FastQ file with UMIs at the start of read1
2. Extracts the UMI sequence (first 8 bases) and creates a tag
3. Stores the UMI in the read comment (FASTQ header)
4. Removes the UMI bases from the read sequence (so they don't interfere with alignment)
5. Outputs modified reads with UMI preserved in the header

## Input Files

- `input/sample_R1.fq` - Reads with 8bp UMI at the start

## Output Files

- `output_R1.fq` - Reads with UMI in comment, UMI bases removed from sequence

## Configuration Highlights

```toml
[[step]]
    # Extract UMI from positions 0-7 (8 bases)
    action = 'ExtractRegions'
    label = 'umi'
    regions = [{segment = 'read1', start = 0, length = 8}]

[[step]]
    # Store UMI in the FASTQ comment
    action = 'StoreTagInComment'
    label = 'umi'

[[step]]
    # Remove the UMI bases from the read
    action = 'CutStart'
    target = 'Read1'
    n = 8
```

## Workflow Details

**Before processing:**
```
@READ1
ATCGATCGACTGTACTGTACTGTACTGTACTG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
```

**After processing:**
```
@READ1 umi:ATCGATCG
ACTGTACTGTACTGTACTGTACTG
+
IIIIIIIIIIIIIIIIIIIIIIII
```

The UMI `ATCGATCG` is now in the comment and removed from the sequence.

## When to Use This

- Single-cell RNA-seq with UMIs
- ATAC-seq with UMI-based deduplication
- Any protocol using unique molecular identifiers
- Before alignment when you need to preserve UMIs for downstream duplicate marking

"#,
        toml: r#"[input]
    read1 = 'input/sample_R1.fq'

[[step]]
    # Extract UMI from the first 8 bases of read1
    action = 'ExtractRegions'
    label = 'umi'
    regions = [{segment = 'read1', start = 0, length = 8}]

[[step]]
    # Store the UMI tag in the FASTQ comment
    # This preserves it through alignment and enables UMI-aware deduplication
    action = 'StoreTagInComment'
    label = 'umi'

[[step]]
    # Remove the UMI bases from the read sequence
    # Important: Do this AFTER storing the UMI in the comment
    action = 'CutStart'
    segment = 'read1'
    n = 8

[output]
    prefix = 'output'
    format = \"FASTQ\"
"#,
    },
    Cookbook {
        number: 3,
        name: "03-lexogen-quantseq",
        path: "03-lexogen-quantseq",
        readme: r#"# Cookbook 03: Lexogen QuantSeq Processing

## Use Case

Lexogen QuantSeq is a popular 3' mRNA sequencing protocol optimized for gene expression profiling. The library structure includes:
- **First 8 bases**: UMI (Unique Molecular Identifier) for deduplication
- **Next 6 bases**: Random hexamer primer sequence (needs removal)
- **Remaining sequence**: Actual cDNA from the 3' end of transcripts

This cookbook demonstrates the standard preprocessing for QuantSeq data before alignment.

## What This Pipeline Does

1. Extracts the 8bp UMI from the start of reads
2. Stores the UMI in the read comment (FASTQ header)
3. Removes the first 14 bases total (8bp UMI + 6bp random hexamer)
4. Outputs processed reads ready for alignment

## Input Files

- `input/quantseq_sample.fq` - Raw QuantSeq reads with UMI and random hexamer

## Output Files

- `output_read1.fq` - Processed reads with:
  - UMI stored in comment
  - First 14bp removed
  - Ready for alignment to reference genome

## Workflow Details

**Raw read structure:**
```
@READ1
ATCGATCGTTACGATACTGTACTGTACTGTAC...
^^^^^^
      ^^^^
UMI   Hexamer  <- These get removed
          ^^^^^^^^^^... <- This stays for alignment
```

**After processing:**
```
@READ1 umi:ATCGATCG
ACTGTACTGTACTGTAC...
```

The UMI is preserved in the comment for downstream deduplication, and the adapter/primer sequences are removed.

## When to Use This

- Processing Lexogen QuantSeq FWD/REV libraries
- Any 3' RNA-seq protocol with UMI + random primer structure
- Before aligning to reference genome for gene expression analysis

## Downstream Analysis

After processing with this cookbook:

1. **Align to reference genome** using STAR, HISAT2, or similar
2. **Assign to genes** using [mbf-bam-quantifier](https://tyberiusprime.github.io/mbf-bam-quantifier/), which also does UMI dedup
3. or **Deduplicate using UMI** with tools like:
   - `umi_tools dedup` (extracts UMI from comment)
   - `fgbio GroupReadsByUmi`
4. **Quantify differential gene expression** with standard DE tools (DESeq2, edgeR)

## Important Notes

- The 6bp random hexamer introduces sequence bias; UMI-based deduplication helps mitigate this
- QuantSeq reads are strand-specific (typically R2/reverse strand)
- Read lengths will be 14bp shorter after processing
- Quality filtering may be beneficial after trimming (see cookbook 03-quality-filtering)

## References

- [Lexogen QuantSeq 3' mRNA-Seq Library Prep Kit](https://www.lexogen.com/quantseq-3mrna-sequencing/)
"#,
        toml: r#"[input]
    # QuantSeq produces single-end reads
    read1 = 'input/quantseq_sample.fq'

[[step]]
    # Extract the 8bp UMI from the start of each read
    # QuantSeq uses 8bp random UMI for PCR duplicate identification
    action = 'ExtractRegions'
    label = 'umi'
    regions = [{segment = 'read1', start = 0, length = 6}]

[[step]]
    # Store the UMI in the FASTQ comment
    # This preserves it for downstream deduplication with umi_tools or similar
    action = 'StoreTagInComment'
    label = 'umi'

[[step]]
    # Remove the first 10 bases from reads:
    # - 6bp UMI
    # - 4bp TATA spacer
    # What remains is the actual cDNA sequence for alignment
    action = 'CutStart'
    segment = 'read1'
    n = 10

[output]
    prefix = 'output'
    format = \"FASTQ\"
"#,
    },
    Cookbook {
        number: 4,
        name: "04-phiX-removal",
        path: "04-phiX-removal",
        readme: r#"# Cookbook 04: phiX removal

## Use Case

You have Illumina default spike-in PhiX in your sequences, and would like
to remove tose reads.


## What This Pipeline Does

1. Quantifies how many kmers of your reads map to the PhiX genome
2. Prepares a table so you can plot a histogram.
2. Filters those that have too many phiX kmers.


"#,
        toml: r#"[input]
    read1 = 'input/phix_sample.fq'

[[step]]
    # Extract the 8bp UMI from the start of each read
    # QuantSeq uses 8bp random UMI for PCR duplicate identification
    action = 'CalcKmers'
    label = 'phix_kmer_count'
	canonical = true # forward & reverse count
    files = \"input/NC_001422.1.fasta\"
    k = 30

[[step]]
    action = 'StoreTagsInTable'

[[step]]
    action = 'FilterByNumericTag'
	label = \"phix_kmer_count\"
	min_value = 25
	keep_or_remove  = 'remove'

[output]
    prefix = 'output_without_phix'
    format = \"FASTQ\"
"#,
    },
];

/// Get all cookbook names and their paths
pub fn list_cookbooks() -> Vec<(usize, &'static str, &'static str)> {
    COOKBOOKS
        .iter()
        .map(|cb| (cb.number, cb.name, cb.path))
        .collect()
}

/// Get a specific cookbook by number (1-indexed)
pub fn get_cookbook(number: usize) -> Option<&'static Cookbook> {
    COOKBOOKS.iter().find(|cb| cb.number == number)
}

/// Get the total number of cookbooks
pub fn cookbook_count() -> usize {
    COOKBOOKS.len()
}
